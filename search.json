[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Week 5 Reflection\n\n\n\n\n\nWeek 5 Reflection\n\n\n\n\n\nSep 27, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 3 Reflection\n\n\n\n\n\nLab 3 Reflection\n\n\n\n\n\nSep 20, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 2 Reflection\n\n\n\n\n\nLab 1 Reflection\n\n\n\n\n\nSep 13, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 2 Reflection\n\n\n\n\n\nLab 1 Reflection\n\n\n\n\n\nSep 6, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWelcome! First Week\n\n\n\n\n\nAug 27, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Alisha Chulani is a senior engineering major at Harvey Mudd College interested in electrical engineering, systems engineering, robotics, and hardware/software integration."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "Initial Learnings: I learned how to use Quarto to make a webpage this week!"
  },
  {
    "objectID": "posts/week4.html",
    "href": "posts/week4.html",
    "title": "Week 3 Reflection",
    "section": "",
    "text": "This week, we worked on Lab 3, where we programmed a keypad to display numbers on a double 7-segment display (same display as last week).\nThis week’s lab was pretty up and down for me. There were times where I was super confuident in what I was doing and felt like I had a solid grip on the concepts, and other times where I felt like nothing in the lab made any sense and I felt so lost and overwhelmed on how to address certain issues.\nHowever, this was a lesson of patience and debugging for me. I actually felt pretty confident as I was getting the implementation set up - once I had a general understanding of the lab and had completed a thorough planning phase with block diagrams and schematics, the SystemVerilog writing and simulating went relatively smoothly. There were, of course, debugging stages that needed to occur since obviously everything wasn’t perfect the first time, but these were expected and I was able to overcome them with normal effort.\nSimilarly, switching over my design to hardware was also somewhat painless. Some debugging needed here and there, but all expected and at a normal amount.\nThe problem hit after the Thursday checkoff - there was a bug that I was not aware of that was uncovered during the checkoff that threw me for a loop for the rest of the weekend. It seemed to me that it was relatively minor, and I though I had a good handle on how to fix it until I tried to do so and could not figure out the optimal position to add in the conditional. For a bug that that seemed so minor to the user took me longer than I would like to admit to fix, and it was also frustrating to me because even after fixing the bug, it didn’t feel like there was such a huge payoff as if I had implemented something brand new.\nI did learn a few things about my debugging style however which was a good outcome of this whole process. First, I realized the importance of taking breaks. When I was racking my brain for too long at a time, I got easily frustrated and then could not think clearly. Taking a break to get out of the lab and get some fresh air, or doing some other work to excersize some other muscles in my brain would then help me come back to the debugging process with some fresh perspective. Also, talking it out with classmates and TAs was super helpful also. They were able to give me some new ideas and fresh looks at my design which ultimately helped me be more creative with my solution.\nOverall, while I did not enjoy this lab (lol) I do appreciate the fact that I was able to do it and feel proud of myself for sticking it out through the weekend rather than just giving up and leaving the lab as is."
  },
  {
    "objectID": "posts/week2.html",
    "href": "posts/week2.html",
    "title": "Week 2 Reflection",
    "section": "",
    "text": "This week, we worked on Lab 1, where we soldered and assembled our boards and tested it by making LED sequences and powering a 7-segment display.\nSome learnings I had for this week:\nFirst, START EARLY! I wouldn’t even say I started late persay, but I feel like I could have eased more stress just by alloting more time earlier to prep for the rest of the week. For example, I started soldering my board over the weekend, but did not anticipate how difficult I would find it and thus, how much time it would take. While I still had plenty of time to finish the lab, it would have been good for me to go in a little earlier to gauge.\nSecond, work with other people! Just having friends around me in the lab eased stress because we could struggle together. We could also bounce ideas off each other when things were going wrong, and overall just made the experience more enjoyable. It was also fun to achieve little bits of the lab when I had a friend to celebtrate little wins with.\nLastly, trust the process - the process of building block diagrams and really following the design process through actually helped a lot. At first, I thought I could skip some setup steps and side tutorials in the lab to save some time, but when I got confused later on it just ended up taking more time for me to hunt for answers. I think spreading the lab out would also help with this so I wouldn’t feel so strapped for time and would be ok with going through each of the smaller steps.\nThanks for reading this reflection! Looking forward to next week!"
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "For Lab 3, we used an FPGA to scan inputs from a keypad and display outputs sequentially on a double 7-segment dispplay. There were lots of little caveats to the design that accounted for weird button pressing on the part of the user. A key part of this lab was that each key should only register once, regardless for how long it was pressed and if another button was pressed at the same time. These two things affected the way I designed my lab greatly, because we had to account for many different situations in a clever way.\nThis lab took a lot of pre-thinking and planning in order to fully understand the complexities of what we were tasked to do. In order to start the lab, I started by making an Finite State Machine to understand the flow of the design and what would occur in each state of the design. The State trainsition table followed after.\n\n\n\nFSM for state logic\n\n\n\n\n\nState transition table\n\n\nTo handle switch debouncing, I initialized counters in State 8 that would increment depending on if the button was pressed/unpressed on the clock cycle. If the counterOn fills up first, then the design will transition forward to actually displaying digits, however, if counterOn fills up first, the the deisgn will reset back to State 0 beacuse the design notices that a button is no longer pressed. This was the most logical way I could think of to ensure that debouncing would not throw off the entire design, and works because it allows for this to be contained in one state. I chose to implement it in the software rather than doing hardware switch debouncing (with a RC-circuit) because I thought that the discharging of the capacitor as a debouncing counter would not be as reliable.\nFinal schematics and block diagrams of the Verilog are shown below.\n\n\n\nSchematic of 4x4 keypad and 2 7-segment displays with pins labeled\n\n\n\n\n\nBlock diagram for Verilog of 4x4 keypad and 2 7-segment displays with pins labeled\n\n\nI am glad that I started off finalizing the Verilog through simulation before starting the hardware portion. Simulation screenshots are included below.\n\n\n\nWave forms from testbench\n\n\nI did not even touch the hardware until the simulation was completely working and this allowed for relatively smooth building of the hardware. I did not really have many problems wiring up the hardware and getting it to work similar to the simulation which was mostly due to the thorough work I did leading up to hardware implementation.\nHowever, debugging towards the final stages was where I ran into a lot of problems. I spoke about it in my reflection for this week, but I had a small bug where pressing other buttons in the same row triggered a display of the first button. I spent a great amount of time addressing this bug. Knowing that it would be a minor fix, I still struggled to find exactly where in my Verilog the edit needed to be made. I did not spend enough time really thinking about WHY the problem was occurring and jumped straight into debugging because I felt like I was so close to being done with the lab. I think skipping over the understanding step ultimately meant I spent way more time on debugging than needed.\nUltimately, I learned a lot from this lab both about handling very complex projects and also about my debugging style.\nI spent about 20 hours on this lab"
  },
  {
    "objectID": "labs/lab3/lab3.html#keypad-scanner",
    "href": "labs/lab3/lab3.html#keypad-scanner",
    "title": "Lab 3",
    "section": "",
    "text": "For Lab 3, we used an FPGA to scan inputs from a keypad and display outputs sequentially on a double 7-segment dispplay. There were lots of little caveats to the design that accounted for weird button pressing on the part of the user. A key part of this lab was that each key should only register once, regardless for how long it was pressed and if another button was pressed at the same time. These two things affected the way I designed my lab greatly, because we had to account for many different situations in a clever way.\nThis lab took a lot of pre-thinking and planning in order to fully understand the complexities of what we were tasked to do. In order to start the lab, I started by making an Finite State Machine to understand the flow of the design and what would occur in each state of the design. The State trainsition table followed after.\n\n\n\nFSM for state logic\n\n\n\n\n\nState transition table\n\n\nTo handle switch debouncing, I initialized counters in State 8 that would increment depending on if the button was pressed/unpressed on the clock cycle. If the counterOn fills up first, then the design will transition forward to actually displaying digits, however, if counterOn fills up first, the the deisgn will reset back to State 0 beacuse the design notices that a button is no longer pressed. This was the most logical way I could think of to ensure that debouncing would not throw off the entire design, and works because it allows for this to be contained in one state. I chose to implement it in the software rather than doing hardware switch debouncing (with a RC-circuit) because I thought that the discharging of the capacitor as a debouncing counter would not be as reliable.\nFinal schematics and block diagrams of the Verilog are shown below.\n\n\n\nSchematic of 4x4 keypad and 2 7-segment displays with pins labeled\n\n\n\n\n\nBlock diagram for Verilog of 4x4 keypad and 2 7-segment displays with pins labeled\n\n\nI am glad that I started off finalizing the Verilog through simulation before starting the hardware portion. Simulation screenshots are included below.\n\n\n\nWave forms from testbench\n\n\nI did not even touch the hardware until the simulation was completely working and this allowed for relatively smooth building of the hardware. I did not really have many problems wiring up the hardware and getting it to work similar to the simulation which was mostly due to the thorough work I did leading up to hardware implementation.\nHowever, debugging towards the final stages was where I ran into a lot of problems. I spoke about it in my reflection for this week, but I had a small bug where pressing other buttons in the same row triggered a display of the first button. I spent a great amount of time addressing this bug. Knowing that it would be a minor fix, I still struggled to find exactly where in my Verilog the edit needed to be made. I did not spend enough time really thinking about WHY the problem was occurring and jumped straight into debugging because I felt like I was so close to being done with the lab. I think skipping over the understanding step ultimately meant I spent way more time on debugging than needed.\nUltimately, I learned a lot from this lab both about handling very complex projects and also about my debugging style.\nI spent about 20 hours on this lab"
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "For Lab 5, we were tasked with using interrupts to measure the speed of a motor from quadrature encoder readings. By reading quarature encoder pulses using the MCU, we can then process these pulses and the difference between them using interrupts to cacluate and display the speed of the motor in RPM.\nI used pins A6 and A9 to read the quadrature encoder pulses as both of these pins were 5V tolerant. The motor was powered by an external power supply. The figure below shows a schematic of the hardware setup.\n\n\n\nSchematic\n\n\nThe use of interrupts is espeically handy for this application over manual polling (which checks if the GPIO pin input changes at every clock) at high speeds because it is faster at processing changes in input. Manual polling can often take too long to evaluate within the while loop, raising concern of missing signal changes. On the other hamd, interrupts allow for the MCU to immediately note when a signal is changed by noting a rising or falling edge, triggering a service routine. This process is shown in the flow chart below.\n\n\n\nFlow Chart showing use of interrupts\n\n\nIn order to confirm that the output voltages that were being displayed were reasonable, I used the following equation (1), which uses the rated voltage and RPM provided in the datasheet to essentially create a ratio of voltage to RPM. The following image also shows some sample reference RPMs that I used to verify that my measurements were accurate. Given that these are ideal calculations and there could be a lot of error associated with polling interrupts I allowed for error of ~0.3. The RPMs that are displayed in the debug cell are quite accurate to my hand calculated values.\n\n\n\nCalculations used to verify accuracy of design\n\n\nUsing the oscilliscope came in handy to first visualize the signals that were being outputted by the quadrature encoder and needed to be processed by the MCU interrupt setup. Overall, I thought most of my time on this lab were at first getting a good understanding of what I even needed to do - how the interrupts worked and why/how they were to be used for this use case was the most time consuming part for me. I found that the code itself followed in a relatively straightforward manner given the background and experience we got from last week’s Lab 4.\nI spent a total of 10 hours on this lab."
  },
  {
    "objectID": "labs/lab5/lab5.html#interrupts",
    "href": "labs/lab5/lab5.html#interrupts",
    "title": "Lab 5",
    "section": "",
    "text": "For Lab 5, we were tasked with using interrupts to measure the speed of a motor from quadrature encoder readings. By reading quarature encoder pulses using the MCU, we can then process these pulses and the difference between them using interrupts to cacluate and display the speed of the motor in RPM.\nI used pins A6 and A9 to read the quadrature encoder pulses as both of these pins were 5V tolerant. The motor was powered by an external power supply. The figure below shows a schematic of the hardware setup.\n\n\n\nSchematic\n\n\nThe use of interrupts is espeically handy for this application over manual polling (which checks if the GPIO pin input changes at every clock) at high speeds because it is faster at processing changes in input. Manual polling can often take too long to evaluate within the while loop, raising concern of missing signal changes. On the other hamd, interrupts allow for the MCU to immediately note when a signal is changed by noting a rising or falling edge, triggering a service routine. This process is shown in the flow chart below.\n\n\n\nFlow Chart showing use of interrupts\n\n\nIn order to confirm that the output voltages that were being displayed were reasonable, I used the following equation (1), which uses the rated voltage and RPM provided in the datasheet to essentially create a ratio of voltage to RPM. The following image also shows some sample reference RPMs that I used to verify that my measurements were accurate. Given that these are ideal calculations and there could be a lot of error associated with polling interrupts I allowed for error of ~0.3. The RPMs that are displayed in the debug cell are quite accurate to my hand calculated values.\n\n\n\nCalculations used to verify accuracy of design\n\n\nUsing the oscilliscope came in handy to first visualize the signals that were being outputted by the quadrature encoder and needed to be processed by the MCU interrupt setup. Overall, I thought most of my time on this lab were at first getting a good understanding of what I even needed to do - how the interrupts worked and why/how they were to be used for this use case was the most time consuming part for me. I found that the code itself followed in a relatively straightforward manner given the background and experience we got from last week’s Lab 4.\nI spent a total of 10 hours on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "The goals of this lab were to fully solder and set up our boards for the rest of the semester, and test that everything was working correctly. First, I soldered surface mount pieces, then the through hole technology to the PCB before testing that everything powered correctly. Then, I tested the LEDs and connections through a simple blinking program. Finally, I programmed a 7-segment display to display digits 0-F.\nFor this report, I will focus on the 7-segment display as the main design goal. Schematics are shown below.\n\n\n\nSchematic of 7-segment display and LEDs with pins labeled\n\n\nTo design the 7-bit display, I first looked at the datasheets to get acquainted with the 7-bit display we were provided with. I needed to get acquainted with the hardware pieces first, as I knew the coding bit of it would be relatively straightforward (just pushing 1s and 0s through to the segments based on switch inputs - an always_comb block). This proved to be the hardest step for me because I struggled to sift through the datasheet to understand exactly how things should be wired.\nThe coding was relatively straightforward. A block diagram is shown below. \nTo verify that the design was behaving as expected, I simply used the switches to toggle through all 17 options. I had some problems with wiring in the exact correct way, so based off of this, I switched around some of the wiring to have the display be accurate. My debug method for the wires was mostly guess and check though, which would only be a reasonable approach for a project that is as small as this one.\nThe design meets all requirements. The 7-segment display light up according to bit switch inputs, and the LEDs on the side of the board also light up corresponding to and and xor gates.\nAs part of an excellence requirement, I inspected the datasheet further to find desired voltage and current for each segment, then performed simple V=iR algebra to find a resistor value that would make each segment light up at the same brightness.\n\n\n\nCalculations for resistor values\n\n\nLastly, I forced all of the possible switch values to simulate that the 7 segment display was working correctly for excellence requirements.\n\n\n\nWave forms for forced values\n\n\nI spent about 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#fpga-and-mcu-setup-and-testing",
    "href": "labs/lab1/lab1.html#fpga-and-mcu-setup-and-testing",
    "title": "Lab 1",
    "section": "",
    "text": "The goals of this lab were to fully solder and set up our boards for the rest of the semester, and test that everything was working correctly. First, I soldered surface mount pieces, then the through hole technology to the PCB before testing that everything powered correctly. Then, I tested the LEDs and connections through a simple blinking program. Finally, I programmed a 7-segment display to display digits 0-F.\nFor this report, I will focus on the 7-segment display as the main design goal. Schematics are shown below.\n\n\n\nSchematic of 7-segment display and LEDs with pins labeled\n\n\nTo design the 7-bit display, I first looked at the datasheets to get acquainted with the 7-bit display we were provided with. I needed to get acquainted with the hardware pieces first, as I knew the coding bit of it would be relatively straightforward (just pushing 1s and 0s through to the segments based on switch inputs - an always_comb block). This proved to be the hardest step for me because I struggled to sift through the datasheet to understand exactly how things should be wired.\nThe coding was relatively straightforward. A block diagram is shown below. \nTo verify that the design was behaving as expected, I simply used the switches to toggle through all 17 options. I had some problems with wiring in the exact correct way, so based off of this, I switched around some of the wiring to have the display be accurate. My debug method for the wires was mostly guess and check though, which would only be a reasonable approach for a project that is as small as this one.\nThe design meets all requirements. The 7-segment display light up according to bit switch inputs, and the LEDs on the side of the board also light up corresponding to and and xor gates.\nAs part of an excellence requirement, I inspected the datasheet further to find desired voltage and current for each segment, then performed simple V=iR algebra to find a resistor value that would make each segment light up at the same brightness.\n\n\n\nCalculations for resistor values\n\n\nLastly, I forced all of the possible switch values to simulate that the 7 segment display was working correctly for excellence requirements.\n\n\n\nWave forms for forced values\n\n\nI spent about 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "The goals of this lab were to set up a two seven segment display, however, the catch was that we used time multiplexing to efficiently use the I/O on the FPGA. So, using one set of I/O FPGA pins and two transistors, the time multiplexing setup essentially allowed for power to be toggled back and forth on the two displays at a speed too fast to be processed by the human eye, thus appearing as two constant displays instead. In addition to the displays, a set of 5 LEDs also shows the sum of the two numbers being displayed. Schematics and a block diagram are shown below.\n\n\n\nSchematic of 7-segment display and LEDs with pins labeled\n\n\nTo design the 7-bit display, I first looked at the datasheets to get acquainted with the 7-bit display we were provided with, as we shifted on to a double digit version which was different than the one being used last week. I needed to get acquainted with the hardware pieces first to fully think through the system at hand. I found that thinking through schematics and block diagrams to really visualize the hardware and signal flow was an important first step for a more complex lab like this one.\nThe coding was more complex than last week, and required a thorough note-taking and scribbling thinking process to fully understand the set of inputs, outputs, and dependencies for the entire system. A block diagram is shown below.\n\n\n\nBlock diagram for Verilog of 7-segment display and LEDs with pins labeled\n\n\nThere was a long debugging process throughout the entire lab work. First, there were plenty of syntax errors with my SystemVerilog that had to be addressed in order to even flash anything onto the FPGA. Most of this process had to do with addressing compile issues in Lattice Radiant itself. Then, even when code would flash, there were plenty of wiring issues to make sure the switches were arranged in a user-friendly way and that the correct segments were lighting up when needed. The debugging process for the segments of just pulling wires here and there did not work well this time, and it took some further datasheet inspection and fiddling to get this working correctly.\nThe design meets all requirements. The two digit 7-segment display light up according to bit switch inputs, and the LEDs on the side of the board also light up corresponding to sums.\nAs part of an excellence requirement, I inspected the datasheet further to find desired currents for the FPGA pins, then performed current limiting calculations to find a resistor value that would fit operating conditions.\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\n\n\n\nCalculations for resistor values\n\n\nLastly, I wrote a testbench to simulate that the two digit 7 segment display was working correctly for excellence requirements.\n\n\n\nWave forms for forced values\n\n\nI spent about 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#multiplexed-7-segment-display",
    "href": "labs/lab2/lab2.html#multiplexed-7-segment-display",
    "title": "Lab 2",
    "section": "",
    "text": "The goals of this lab were to set up a two seven segment display, however, the catch was that we used time multiplexing to efficiently use the I/O on the FPGA. So, using one set of I/O FPGA pins and two transistors, the time multiplexing setup essentially allowed for power to be toggled back and forth on the two displays at a speed too fast to be processed by the human eye, thus appearing as two constant displays instead. In addition to the displays, a set of 5 LEDs also shows the sum of the two numbers being displayed. Schematics and a block diagram are shown below.\n\n\n\nSchematic of 7-segment display and LEDs with pins labeled\n\n\nTo design the 7-bit display, I first looked at the datasheets to get acquainted with the 7-bit display we were provided with, as we shifted on to a double digit version which was different than the one being used last week. I needed to get acquainted with the hardware pieces first to fully think through the system at hand. I found that thinking through schematics and block diagrams to really visualize the hardware and signal flow was an important first step for a more complex lab like this one.\nThe coding was more complex than last week, and required a thorough note-taking and scribbling thinking process to fully understand the set of inputs, outputs, and dependencies for the entire system. A block diagram is shown below.\n\n\n\nBlock diagram for Verilog of 7-segment display and LEDs with pins labeled\n\n\nThere was a long debugging process throughout the entire lab work. First, there were plenty of syntax errors with my SystemVerilog that had to be addressed in order to even flash anything onto the FPGA. Most of this process had to do with addressing compile issues in Lattice Radiant itself. Then, even when code would flash, there were plenty of wiring issues to make sure the switches were arranged in a user-friendly way and that the correct segments were lighting up when needed. The debugging process for the segments of just pulling wires here and there did not work well this time, and it took some further datasheet inspection and fiddling to get this working correctly.\nThe design meets all requirements. The two digit 7-segment display light up according to bit switch inputs, and the LEDs on the side of the board also light up corresponding to sums.\nAs part of an excellence requirement, I inspected the datasheet further to find desired currents for the FPGA pins, then performed current limiting calculations to find a resistor value that would fit operating conditions.\nCurrent draw/sink on all FPGA pins are below the currents specified in the recommended operating conditions. Claims are backed up by calculations and reference to the appropriate items on the datasheet.\n\n\n\nCalculations for resistor values\n\n\nLastly, I wrote a testbench to simulate that the two digit 7 segment display was working correctly for excellence requirements.\n\n\n\nWave forms for forced values\n\n\nI spent about 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Lab 4 was our introduction to using our STM32 Microcontroller. We used the microcontroller to generate sqaure waves at specified frquencies by toggling a GPIO pin, which would then power a 8ohm speaker to play a song, specifically Fur Elise. I also created a array of frequency and durations to allow the speaker to play Twinkle Twinkle Little Star.\nThe hardware setup for this lab was relatively straightforward - I used GPIO pin A5 and to output the square waves, which then feeds into a 10Kohm digital potentiometer to control the output volume. Then, the wave will be fed into the LM386 audio amplifier and an 8-ohm speaker to play the notes. The following figure shows the schematic for this setup.\n\n\n\nSchematic\n\n\nThe image below shows the math used to calculate ARR for specified frequencies. I started with equation (1), which shows the frequency in terms of ARR, and rearranged it to get equation (2), which shows the ARR in terms of desired frequency (which would be inputted through our array of notes and durations).\n\n\n\nRearranging equations to find ARR in terms of desired input frequency\n\n\nI will also include a sample calculation using an example input frequency to prove that this allows for the necessary accuracy of 1%. Let’s say we have a desired frequency of 659 Hz. Starting with equation (2) from above, we can calculate an ARR of 46.42, but this would round down to 46. This shows that this is a good example to use because we are trunctating the ARR by over 0.4.\nThen, we can work backward using this calculated ARR by plugging into equation 1 to see the actual output frequency, which comes out to be 664.89Hz. We can then confirm that this is within 1% error to the actual desired frequency using the equation for scientific error.\n\n\n\nCalculations to prove 1% accuracy\n\n\nI only used 1 timer to toggle the GPIO pin at specified square waves, and used a nop while loop for the delay function. This is what controls the duration piece of the notes, and I am using 887 nop instructions for the delay, meaning that the minimum delay/duration that is possible is 1/887 which is 1ms. The nop instruction method also allows for an unbounded maximum duration.\nThe figure below includes calculations for minimum and maximum frequencies using the same equation (1) from above.\n\n\n\nWave forms from testbench\n\n\nThe range from 0.477Hz to 32150Hz is a sufficient range for the human ear.\nThe following videos show Fur Elise and my rendition of Twinkle Twinkle Little Star playing using the setup detailed above.\n\n\nOverall, I thought that this lab was a great introduction to using the MCU and although there were some initial learning curves at the beginning (I did not feel very confident in my C and was out of practice), I feel a little more caught up after struggling with this lab. This was also an interesting shift from the other labs where the hardware was super straightforward and was something I could wire up first. I also felt like it was hard to do preplanning for this lab (like draw schematics or block diagrams) which was werid to me after getting into that habit from the previous few labs. Debuggina also felt like a learning curve because it had been a long time since using the Segger tools. It took me about 8 hours in total to complete."
  },
  {
    "objectID": "labs/lab4/lab4.html#digital-audio",
    "href": "labs/lab4/lab4.html#digital-audio",
    "title": "Lab 4",
    "section": "",
    "text": "Lab 4 was our introduction to using our STM32 Microcontroller. We used the microcontroller to generate sqaure waves at specified frquencies by toggling a GPIO pin, which would then power a 8ohm speaker to play a song, specifically Fur Elise. I also created a array of frequency and durations to allow the speaker to play Twinkle Twinkle Little Star.\nThe hardware setup for this lab was relatively straightforward - I used GPIO pin A5 and to output the square waves, which then feeds into a 10Kohm digital potentiometer to control the output volume. Then, the wave will be fed into the LM386 audio amplifier and an 8-ohm speaker to play the notes. The following figure shows the schematic for this setup.\n\n\n\nSchematic\n\n\nThe image below shows the math used to calculate ARR for specified frequencies. I started with equation (1), which shows the frequency in terms of ARR, and rearranged it to get equation (2), which shows the ARR in terms of desired frequency (which would be inputted through our array of notes and durations).\n\n\n\nRearranging equations to find ARR in terms of desired input frequency\n\n\nI will also include a sample calculation using an example input frequency to prove that this allows for the necessary accuracy of 1%. Let’s say we have a desired frequency of 659 Hz. Starting with equation (2) from above, we can calculate an ARR of 46.42, but this would round down to 46. This shows that this is a good example to use because we are trunctating the ARR by over 0.4.\nThen, we can work backward using this calculated ARR by plugging into equation 1 to see the actual output frequency, which comes out to be 664.89Hz. We can then confirm that this is within 1% error to the actual desired frequency using the equation for scientific error.\n\n\n\nCalculations to prove 1% accuracy\n\n\nI only used 1 timer to toggle the GPIO pin at specified square waves, and used a nop while loop for the delay function. This is what controls the duration piece of the notes, and I am using 887 nop instructions for the delay, meaning that the minimum delay/duration that is possible is 1/887 which is 1ms. The nop instruction method also allows for an unbounded maximum duration.\nThe figure below includes calculations for minimum and maximum frequencies using the same equation (1) from above.\n\n\n\nWave forms from testbench\n\n\nThe range from 0.477Hz to 32150Hz is a sufficient range for the human ear.\nThe following videos show Fur Elise and my rendition of Twinkle Twinkle Little Star playing using the setup detailed above.\n\n\nOverall, I thought that this lab was a great introduction to using the MCU and although there were some initial learning curves at the beginning (I did not feel very confident in my C and was out of practice), I feel a little more caught up after struggling with this lab. This was also an interesting shift from the other labs where the hardware was super straightforward and was something I could wire up first. I also felt like it was hard to do preplanning for this lab (like draw schematics or block diagrams) which was werid to me after getting into that habit from the previous few labs. Debuggina also felt like a learning curve because it had been a long time since using the Segger tools. It took me about 8 hours in total to complete."
  },
  {
    "objectID": "posts/week3.html",
    "href": "posts/week3.html",
    "title": "Week 2 Reflection",
    "section": "",
    "text": "This week, we worked on Lab 2, where we programmed a 2-digit 7-segment display using multiplexing techniques.\nI honestly thought this week’s lab went way smoother for me. I am surprised honestly that I felt more confident for this lab and could feel my debugging and thinking skills improved from even just a week ago. I know that this will come crashing down next week during Lab 3, but it felt good to feel like I learned something and developed my skills already in such a short time.\nI definitely implemented my learnings from last week which probably helped me feel better about this lab. I coordinated times with people to go in several days before the lab was due, and I sat down and thought through the entire lab and scribbled out notes before even touching hardware or software. This initial process was super helpful for me, and I think will be super helpful to do the same going into the next lab.\nI am a little nervous going into next week becuase I have a busy weekend with tennis, clinic, and other things going on. I worry I won’t be able to get ahead on this lab like I had hoped, but we will see how it goes! I have been enjoying the routine of going into the lab in the evenings and find myself getting lost in the work and losing track of time. Honeslty, I can’t ask for much more - I’m enjoying the class and the learning process, and that’s what counts."
  },
  {
    "objectID": "posts/week5.html",
    "href": "posts/week5.html",
    "title": "Week 5 Reflection",
    "section": "",
    "text": "This week, no lab was due which was really nice to recoup from a tough first few weeks and catch up on everything I needed to do. I want to keep the reflection short this week because I don’t have a lot to reflect on for MicroPs this week, but overall I am learning the importance of taking breaks especially when there are many tough and long weeks in consecutive. I also learned about the importance of taking breaks in the middle of tough and long labs - which I talked about in my previous reflection.\nI have to say I really appreciate the midway break for the labs and maybe this could be implemented for future years? This is a tough time for most students with clinic, midterms, etc, and also it’s flu season…just a thought!"
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 5\n\n\n\n\n\n\n\n\n\n\n\nOct 23, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\n\n\n\n\n\n\n\n\n\nOct 10, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\n\n\n\n\n\n\n\n\n\nSep 19, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\n\n\n\n\n\n\nSep 12, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\n\n\n\n\n\n\n\n\n\nSep 4, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\n\n\n\n\n\n\nLab 7\n\n\n\n\n\n\n\n\n\n\n\nAug 27, 2024\n\n\nAlisha Chulani\n\n\n\n\n\n\nNo matching items"
  }
]